<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>voc 首页</title>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=IE8">
    <link rel="stylesheet" type="text/css" href="./css/base.css"/>
    <link rel="stylesheet" type="text/css" href="./css/pt.css"/>
    <link rel="stylesheet" type="text/css" href="./css/yq.css"/>
    <link rel="stylesheet" type="text/css" href="./css/wt.css"/>
    <link rel="stylesheet" type="text/css" href="./css/jp.css"/>
    <link rel="stylesheet" type="text/css" href="./css/bz.css"/>
    <link rel="stylesheet" type="text/css" href="./css/swiper.min.css"/>
    <script src="./js/jquery-1.11.3.min.js"></script>
</head>
<body>
<canvas width="1000" height="1000" style="border:1px solid red;" id="canvas"></canvas>
</body>
<script type="text/javascript">


    window.requestAnimationFrame = (function () {

        return window.requestAnimationFrame ||    //IE10以及以上版本，以及最新谷歌，火狐版本

            window.webkitRequestAnimationFrame ||  //谷歌老版本

            window.mozRequestAnimationFrame ||//火狐老版本

            function (callback) {  //IE9以及以下版本

                return window.setTimeout(callback, 1000 / 60);//这里强制让动画一秒刷新60次，这里之所以设置为16.7毫秒刷新一次，是因为requestAnimationFrame默认也是16.7毫秒刷新一次。

            }
    })();

    window.cancelAnimationFrame = (function () {

        return window.cancelAnimationFrame ||    //IE10以及以上版本，以及最新谷歌，火狐版本

            window.webkitCancelAnimationFrame ||  //谷歌老版本

            window.mozCancelAnimationFrame ||//火狐老版本

            window.clearTimeout
    })();


    /**
     *
     *
     * 画布对象
     *
     *
     *
     * */
    function CanvasAnimate(opts) {
        this.opts = $.extend(true, {}, opts);
        this.c = opts.c;
        this.ctx = opts.c.getContext("2d");
        this.object2dAnimateQueue = [];
        this.loopAnimate();
        return this
    }
    /**
     *
     *
     * 为动画添加效果和时效*
     *
     * */
    function AnimateCounter(opts) {
        var def = {
            start: 0,
            end: 0,
            duration: 500,
            animateType: "easeOutQuad",
            loop:false,//值会跳会开始位置
            rockback:false//值会回滚到原来位置
        }
        $.extend(this, def, opts);
    }
    /**
     *
     * 粒子对象
     *
     * */
    function Particle(opts) {
        var def = {

            //划线
            animateLineOpts:{
                duration:500,
                animateType: "easeOutQuad",
            },

            //点是闪烁
            flashOpts:{
                duration:500,
                animateType: "easeOutQuad",
                start:1,
                end:4,
                rockback:true
            },

            x: 0,
            y: 0
        }
        $.extend(this, def, opts);
    }


    /**
     *
     * 动画对象
     *
     *
    * */
    function Object2d(opts) {
        
        var def = {
            rotateAnimateOpts:{
              start:0, end:360,
                loop:true,
                animateType:"linear"
            },
            promise:$.Deferred(),
            id:this.__proto__.uuid++,
            render:null,
            delay:0, //延迟时间
            count:0,
            drawData :[],
            opts:{
                data:[]
            }
        }

        $.extend(this,def,opts);

        //将原始数据转换为粒子对象
        for (var i = 0; i < opts.data.length; i++) {
            this.opts.data.push(new Particle(opts.data[i]))
        }

        this.copyData = $.extend([], this.opts.data);

        return this
    }


    /**
     *
     *
     * 将单个整体的动画添加到画布中
     *
     *
     * */
    CanvasAnimate.prototype.pushAnimate = function (object2d) {
        this.object2dAnimateQueue.push(object2d);
        return object2d.promise;
    }

    /**
     *
     *
     *
     * 画布遍历对象开始画图
     *
     *
     * */
    CanvasAnimate.prototype.loopAnimate = function () {

        //画布对象
        var canvasObj = this;

        //一组动画对象
        var object2dGroup = canvasObj.object2dAnimateQueue;

        //重新绘制
        canvasObj.c.width = canvasObj.c.width;

        //防止连续调用
        cancelAnimationFrame(canvasObj.timer);

        var len = object2dGroup.length;
        var j = 1;
        for (var i = 0; i < j; i++) {
            //前面已经ok了就可以播放下个
            if (object2dGroup[i] && object2dGroup[i].draw(canvasObj) === true) {
                j++;
                if (j > len) {
                    j == len;
                }
            }
        }

        //直接锁住画布，可以停在重绘
        if (!canvasObj.lock) {
            canvasObj.timer = requestAnimationFrame(function () {
                canvasObj.loopAnimate();
            });
        }
    }

    /**
     *
     * 动画函数
     * t: current time, b: begInnIng value, c: change In value, d: duration
     *
     * */
    AnimateCounter.prototype.animateFunc = {
        easeInQuad: function (x, t, b, c, d) {
            return c * (t /= d) * t + b;
        },
        easeOutQuad: function (x, t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b;
        },
        linear:function (x,t,b,c,d) {
            return c/d*t+b;
        }
    };

    /**
     *
     *
     *
     * 画点闪烁
     *
     *
     *
     * */
    CanvasAnimate.prototype.drawGroupDian = function (dian, object2d) {


       dian.flash = dian.flash|| new AnimateCounter(dian.flashOpts)
        //根据粒子对象

        var r = dian.flash.getCount();

        //开始一个新的绘制路径
        var c = this.c;
        var ctx = this.ctx;
        ctx.beginPath();
        ctx.shadowColor = "#65b4ec";
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.shadowBlur = 2;
        ctx.fillStyle = "#65b4ec";

        if(r>0){
            ctx.arc(dian.x, dian.y, r, 0, Math.PI * 2, false);
        }

        ctx.fill()
    }


    /**
     *
     *
     *
     * 获取当前动画的参数
     *
     *
     *
     * */
    AnimateCounter.prototype.getCount = function () {

        if (!this._startTime) {
            this._startTime = new Date().getTime();
        }

        this._currentTime = new Date().getTime() - this._startTime;

        //不循环动画
        if (this.loop) {
            if (this._currentTime > this.duration ) {
                this._startTime = new Date().getTime();
                this._currentTime = this.duration;
            }
            //循环动画
        } else if(this.rockback){
            if (this._currentTime > (this.duration * 2)) {
                this._startTime = new Date().getTime();
                this._currentTime = this.duration * 2;
            }
        }else{
            if (this._currentTime > this.duration) {
                this._currentTime = this.duration;
            }
        }
        return this.animateFunc[this.animateType](null, this._currentTime, this.start, this.end - this.start, this.duration)
    }

    /**
     *
     *
     *
     * 旋转动画
     *
     *
     * */
    CanvasAnimate.prototype.rotate = function (object2d) {
        //开始一个新的绘制路径
        var ctx = this.ctx;
        var x = 238;
        var y = 172;
        var width = 50;
        var height = 50;
        ctx.translate(x+.5*width,y+.5*height);
        object2d.rotateAnimate = object2d.rotateAnimate || new AnimateCounter(object2d.rotateAnimateOpts);
        ctx.rotate(object2d.rotateAnimate.getCount() * Math.PI / 180);
//        ctx.save();
    }

    /**
     *
     *
     *
     * 由一个点对应多个点逐步画线,已经显示的点才可以连线
     *
     *
     * */
    CanvasAnimate.prototype.drawGroupLine = function (dian, object2d) {
        dian.visibility = true;


        var lineTos = dian.lineTo.split(",");
        var count = 0;
        for (var i = 0; i < lineTos.length; i++) {

            //根据对应的点来画线
            var dian2 = object2d.opts.data[(lineTos[i] * 1)];

            //这两个点都存在，且已经显示
            if (dian2 && dian2.visibility) {

                //已两个点作为线对象的id

                var lineId = "dian" + dian.index + "dian" + dian2.index;

                var lineObj = dian[lineId] = dian[lineId] || new AnimateCounter( dian.animateLineOpts );

                this.drawLine(dian, dian2, lineObj);

                if (lineObj.lineok) {
                    count++
                }
            }

        }

        // 该点对应的线全部ok了
        if (count >= lineTos.length) {
            dian.lineok = true;
        }
    }
    /**
     *
     *
     *
     * 由一个点对应多个点逐步画线
     *
     *
     * */
    CanvasAnimate.prototype.drawLine = function (dian1, dian2, lineObj) {

        var x, y;

        if (dian1.x == dian2.x) {
            x = dian1.x;
            lineObj.start = dian1.y;
            lineObj.end = dian2.y
            y = lineObj.getCount();
        } else {
            lineObj.start = dian1.x;
            lineObj.end = dian2.x;
            x = lineObj.getCount();
            y = (x - dian2.x) / (dian1.x - dian2.x) * (dian1.y - dian2.y) + dian2.y;
        }

        /*误差在0.5之内算ok*/
        if (Math.abs(y - dian2.y) < 0.5) {
            lineObj.lineok = true;
        }

        var c = this.c;
        var ctx = this.ctx;
        ctx.beginPath();
        ctx.strokeStyle = "rgba(0,0,0,0.8)";
        ctx.moveTo(dian1.x, dian1.y);
        ctx.lineTo(x, y);
        ctx.stroke();
    }


    Object2d.prototype.uuid = 0;

    /**
     *
     *
     *
     * 开启画笔
     *
     *
     * */
    Object2d.prototype.draw = function (canvasObj) {

        //第一次的开始时间
        if (!this._startTime) {
            this._startTime = new Date().getTime();
        }

        //当前时间
        this._currentTime = new Date().getTime() - this._startTime;

        //延时
        if (this._currentTime > this.delay) {
            if (typeof this.render == "function") {

                /*已返回值来做判断动画可以过渡到下一帧*/
                var status = this.render(canvasObj);

                // 提供一个整体的时间，执行了1666次之后归0
                this.count++;
                if (this.count > 100000) {
                    this.count = 0
                }

                //返回状态
                return status;
            }
        }
    }

    /**
     *
     *
     *
     * 绘画的时间分解
     *
     *
     * */
    Object2d.prototype.pll = function (callback, time) {
        var flag = this.count % Math.floor(time / 16.7);//3*16.7
        if (flag == 0) {
            callback.call(this)
        }
    }

    var canvasAnimate = new CanvasAnimate({c: $("#canvas")[0]});

    canvasAnimate.pushAnimate(new Object2d({
            data: [{"x":238.33331298828125,"y":172,"index":0,"lineTo":"18,17,19,20,1"},{"x":320.33331298828125,"y":154,"index":1,"lineTo":"0,20,22,2"},{"x":400.33331298828125,"y":196,"index":2,"lineTo":"1,22,12,3"},{"x":440.33331298828125,"y":274,"index":3,"lineTo":"2,12,11,13"},{"x":374.33331298828125,"y":248,"index":4,"lineTo":"12,22,21,5,30,11"},{"x":326.33331298828125,"y":272,"index":5,"lineTo":"21,4,30,6,7"},{"x":266.33331298828125,"y":266,"index":6,"lineTo":"5,21,19,23,7,9"},{"x":298.33331298828125,"y":324,"index":7,"lineTo":"5,6,9,8,31,30"},{"x":270.33331298828125,"y":370.03125,"index":8,"lineTo":"7,9,24,27,31"},{"x":234.33331298828125,"y":322.03125,"index":9,"lineTo":"6,23,15,24,8,7"},{"x":388.33331298828125,"y":358.03125,"index":10,"lineTo":"30,31,29,13,11"},{"x":416.33331298828125,"y":298.03125,"index":11,"lineTo":"3,12,4,30,10,13"},{"x":414.33331298828125,"y":234.03125,"index":12,"lineTo":"2,3,11,4,22"},{"x":422.33331298828125,"y":354.03125,"index":13,"lineTo":"11,3,10,14"},{"x":380.33331298828125,"y":402.03125,"index":14,"lineTo":"13,29"},{"x":180.33331298828125,"y":312.03125,"index":15,"lineTo":"16,17,23,9,24,25"},{"x":162.33331298828125,"y":290.03125,"index":16,"lineTo":"18,17,15,25"},{"x":186.33331298828125,"y":236.03125,"index":17,"lineTo":"18,0,19,23,15,16"},{"x":190.33331298828125,"y":212.03125,"index":18,"lineTo":"0,17,16"},{"x":244.33331298828125,"y":212.03125,"index":19,"lineTo":"0,20,21,6,23,17"},{"x":292.33331298828125,"y":172.03125,"index":20,"lineTo":"0,1,22,21,19"},{"x":312.33331298828125,"y":216.03125,"index":21,"lineTo":"20,22,4,5,6,19"},{"x":362.33331298828125,"y":188.03125,"index":22,"lineTo":"1,2,12,4,21,20"},{"x":214.33331298828125,"y":266.03125,"index":23,"lineTo":"17,19,6,9,15"},{"x":218.33331298828125,"y":376.03125,"index":24,"lineTo":"9,15,25,26,27,8"},{"x":182.33331298828125,"y":358.03125,"index":25,"lineTo":"16,15,24,26"},{"x":234.33331298828125,"y":412.03125,"index":26,"lineTo":"25,24,27,28"},{"x":286.33331298828125,"y":414.03125,"index":27,"lineTo":"26,24,8,31,29,28"},{"x":310.33331298828125,"y":432.03125,"index":28,"lineTo":"26,27,29"},{"x":364.33331298828125,"y":408.03125,"index":29,"lineTo":"28,27,31,10,13,14"},{"x":362.33331298828125,"y":316.03125,"index":30,"lineTo":"4,5,7,31,10,11"},{"x":334.33331298828125,"y":374.03125,"index":31,"lineTo":"30,10,29,7,8,27"}],
            render: function (canvasObj) {
                //原始长度
                var orgLen = this.opts.data.length;

                //拷贝的长度
                var copyLen = this.copyData.length;

                //产出随机画的点的数据 100ms一次
                if (copyLen) {
                    this.pll(function () {
                        var randomIndex = Math.floor(copyLen * Math.random());
                        var delData = this.copyData.splice(randomIndex, 1);
                        if (delData && delData[0]) {
                            this.drawData.push(delData[0]);
                        }
                    }, 100)
                }

                var defSetting = {
                    strokeStyle: "red",
                    fillStyle: "red",
                    delay: 100,
                    speed: 1000,
                    animate: "easeOutQuad",
                    shadowColor: "#65b4ec",
                    fillStyle: "#65b4ec",
                    shadowBlur: 2
                };

                //根据可画的点来画线，并且根据点来确定线是否ok
                var drawData = this.drawData;
                var len = drawData.length;
                var lineokNum = 0;
                canvasObj.rotate(this);
                for (var i = 0; i < len; i++) {
                    canvasObj.drawGroupLine(drawData[i], this);
                    if (drawData[i].lineok) {
                        lineokNum++;
                    }
                }

                //100ms一次来画点
                for (var i = 0; i < len; i++) {
                    canvasObj.drawGroupDian(drawData[i], this)
                }



                //如果所有的线都画完了，表示这个可以过度到下一动画
                if (orgLen == lineokNum) {
                    this.promise.resolve();
                    return true;
                }
            }
        }))


</script>
</html>